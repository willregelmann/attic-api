"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

scalar JSON

"Can be used as an argument to upload files using https://github.com/jaydenseric/graphql-multipart-request-spec"
scalar Upload @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Upload")

# ===== DATABASE OF THINGS TYPES =====

# Entity from Database of Things (canonical collectibles data)
type Entity {
    id: ID!
    type: String!
    name: String!
    year: Int
    country: String
    attributes: JSON
    image_url: String
    thumbnail_url: String
    representative_image_urls: [String!] @field(resolver: "App\\GraphQL\\Types\\Entity@representativeImageUrls")  # Computed field: up to 5 random images from descendants (empty if collection has own image)
    external_ids: JSON
    created_at: DateTime
    updated_at: DateTime
    similarity: Float  # Similarity score for semantic search results
    parents: [Entity!]  # Parent collections (only populated in hierarchy queries)
}

# Database of Things PageInfo for cursor-based pagination
type DatabaseOfThingsPageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}

# Entity connection for paginated results
type EntityConnection {
    edges: [EntityEdge!]!
    pageInfo: DatabaseOfThingsPageInfo!
}

type EntityEdge {
    node: Entity!
    cursor: String!
}

# Filterable field discovered from collection descendants
type FilterField {
    field: String!
    label: String!
    type: String!
    values: [String!]!
    count: Int!
    priority: Int!
}

# ===== END DATABASE OF THINGS TYPES =====

# ===== USER & AUTH TYPES =====

# User type
type User {
    id: ID!
    name: String!
    email: String!
    email_verified_at: DateTime
    created_at: DateTime!
    updated_at: DateTime!

    "User's custom collections"
    userCollections: [UserCollection!]! @hasMany
}

# User item ownership (pivot with metadata)
# entity_id references Database of Things entity UUID (canonical collectibles data)
type UserItem {
    id: ID!
    user_id: ID!
    entity_id: ID!
    metadata: JSON
    notes: String
    images: JSON  # Array of {original, thumbnail} objects
    created_at: DateTime!
    updated_at: DateTime!

    user: User! @belongsTo
}

# User item with full entity data (for My Collection view)
# Combines UserItem fields with Entity data from Database of Things
type UserItemWithEntity {
    # UserItem fields
    user_item_id: ID!
    user_id: ID!
    user_metadata: JSON
    user_notes: String
    user_images: JSON
    user_created_at: DateTime!
    user_updated_at: DateTime!

    # Entity fields (from Database of Things)
    id: ID!
    type: String!
    name: String!
    year: Int
    country: String
    attributes: JSON
    image_url: String
    thumbnail_url: String
    representative_image_urls: [String!]
    external_ids: JSON
    created_at: DateTime
    updated_at: DateTime
}

# Wishlist entry
# entity_id references Database of Things entity UUID (canonical collectibles data)
type Wishlist {
    id: ID!
    user_id: ID!
    entity_id: ID!
    created_at: DateTime!
    updated_at: DateTime!

    user: User! @belongsTo
}

# Collection statistics
type CollectionStats {
    totalItems: Int!
    catalogedItems: Int!
    ownedItems: Int! @guard
    completionPercentage: Float! @guard
}

# Collection with stats
type CollectionWithStats {
    collection: Entity!
    stats: CollectionStats!
}

# Login response
type AuthPayload {
    access_token: String!
    token_type: String!
    user: User!
}

# API Token type
type ApiToken {
    id: ID!
    name: String!
    abilities: [String!]
    last_used_at: DateTime
    expires_at: DateTime
    created_at: DateTime!
    updated_at: DateTime!
}

# API Token creation response
type ApiTokenPayload {
    token: String!
    apiToken: ApiToken!
}

# Wishlist entry with full entity data (for My Wishlist view)
# Combines Wishlist fields with Entity data from Database of Things
type WishlistWithEntity {
    # Wishlist fields
    wishlist_id: ID!
    user_id: ID!
    wishlist_created_at: DateTime!
    wishlist_updated_at: DateTime!

    # Entity fields (from Database of Things)
    id: ID!
    type: String!
    name: String!
    year: Int
    country: String
    attributes: JSON
    image_url: String
    thumbnail_url: String
    representative_image_urls: [String!]
    external_ids: JSON
    created_at: DateTime
    updated_at: DateTime
}

"""
User's custom collection for organizing owned and wishlisted items
"""
type UserCollection {
    id: ID!
    user_id: ID!
    parent_collection_id: ID
    name: String!
    description: String
    custom_image: String
    linked_dbot_collection_id: ID

    "User who owns this collection"
    user: User! @belongsTo

    "Parent collection (null for root-level collections)"
    parent: UserCollection @belongsTo(relation: "parent")

    "Child collections nested within this collection"
    subcollections: [UserCollection!]! @hasMany(relation: "subcollections")

    "Owned items directly in this collection (non-recursive)"
    items: [UserItemWithEntity!]! @hasMany(relation: "items")

    "Wishlisted items directly in this collection (non-recursive)"
    wishlists: [WishlistWithEntity!]! @hasMany(relation: "wishlists")

    "Progress statistics for this collection"
    progress: CollectionProgress!

    "Representative images for collection thumbnail (up to 4 images)"
    representative_images: [String!]!

    created_at: DateTime!
    updated_at: DateTime!
}

"""
Collection progress statistics
"""
type CollectionProgress {
    "Number of owned items in collection"
    owned_count: Int!

    "Number of wishlisted items in collection"
    wishlist_count: Int!

    "Total items (owned + wishlist)"
    total_count: Int!

    "Completion percentage (owned / total * 100)"
    percentage: Float!

    "Items owned that exist in linked Database of Things collection (null if not linked)"
    official_owned_count: Int

    "Total items in linked Database of Things collection (null if not linked)"
    official_total_count: Int

    "Official set completion percentage (null if not linked)"
    official_percentage: Float
}

"""
View of a user's collection tree at a specific level
"""
type UserCollectionView {
    "Collections at this level"
    collections: [UserCollection!]!

    "Owned items at this level (not in any subcollection)"
    items: [UserItemWithEntity!]!

    "Wishlisted items at this level (not in any subcollection)"
    wishlists: [WishlistWithEntity!]!

    "Current collection (null for root level)"
    current_collection: UserCollection
}

# ===== END USER & AUTH TYPES =====

type Query {
    # ===== AUTHENTICATION =====

    # Current authenticated user
    me: User @auth(guard: "sanctum")

    # ===== DATABASE OF THINGS QUERIES =====

    # Browse collections from Database of Things
    databaseOfThingsCollections(
        first: Int = 50
        after: String
    ): [Entity!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\CollectionsList")

    # Search entities in Database of Things
    databaseOfThingsSearch(
        query: String!
        type: String
        first: Int = 50
    ): [Entity!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\SearchEntities")

    # Semantic search using vector embeddings
    databaseOfThingsSemanticSearch(
        query: String!
        type: String
        first: Int = 20
    ): [Entity!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\SemanticSearch")

    # Get items in a Database of Things collection
    databaseOfThingsCollectionItems(
        collection_id: ID!
        first: Int = 1000
        after: String
    ): [Entity!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\CollectionItems")

    # Get a single entity from Database of Things
    databaseOfThingsEntity(
        id: ID!
    ): Entity @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetEntity")

    # Get parent collections for an item from Database of Things
    databaseOfThingsItemParents(
        item_id: ID!
    ): [Entity!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetItemParents")

    # Get filterable fields for a collection (recursively discovers from all descendants)
    databaseOfThingsCollectionFilterFields(
        collection_id: ID!
    ): [FilterField!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetCollectionFilterFields")

    # Get parent collections for items in a collection (excludes the current collection)
    databaseOfThingsCollectionParentCollections(
        collection_id: ID!
    ): [Entity!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetCollectionParentCollections")

    # ===== USER-SPECIFIC QUERIES (Auth required) =====

    # User's owned items (returns UserItem records with entity_id references)
    # Optional entity_id filter for duplicate detection
    myItems(entity_id: ID): [UserItem!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyItems")

    # User's collection as entities (fetches entity data for owned items with user metadata)
    myCollection: [UserItemWithEntity!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyCollection")

    # User's favorite collections
    myFavoriteCollections: [CollectionWithStats!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyFavoriteCollections")

    # User's API tokens
    myApiTokens: [ApiToken!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyApiTokens")

    # User's wishlist items
    myWishlist: [Wishlist!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyWishlist")
}

type Mutation {
    # ===== AUTHENTICATION =====

    # Login
    login(
        email: String! @rules(apply: ["required", "email"])
        password: String! @rules(apply: ["required"])
    ): AuthPayload! @field(resolver: "App\\GraphQL\\Mutations\\AuthMutations@login")

    # Logout
    logout: String @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\AuthMutations@logout")

    # Register
    register(
        name: String! @rules(apply: ["required", "string", "max:255"])
        email: String! @rules(apply: ["required", "email", "unique:users,email"])
        password: String! @rules(apply: ["required", "min:8"])
    ): AuthPayload! @field(resolver: "App\\GraphQL\\Mutations\\AuthMutations@register")

    # Google OAuth login
    googleLogin(
        google_token: String! @rules(apply: ["required"])
    ): AuthPayload! @field(resolver: "App\\GraphQL\\Mutations\\AuthMutations@googleLogin")

    # ===== USER ITEM MANAGEMENT (Auth required) =====

    # Add item to user's collection (entity_id references Database of Things entity)
    addItemToMyCollection(
        entity_id: ID!
        metadata: JSON
        notes: String
        images: [Upload!]  # GraphQL multipart upload
    ): UserItem! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserItemMutations@addItemToMyCollection")

    # Update user's item (user_item_id targets specific copy)
    updateMyItem(
        user_item_id: ID!  # Changed from entity_id to target specific copy
        metadata: JSON
        notes: String
        images: [Upload!]  # Add new images
        remove_image_indices: [Int!]  # Remove specific images by index
    ): UserItem! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserItemMutations@updateMyItem")

    # Remove item from user's collection (user_item_id targets specific copy)
    removeItemFromMyCollection(
        user_item_id: ID!  # Changed from entity_id to target specific copy
    ): String! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserItemMutations@removeItemFromMyCollection")

    # Favorite a collection
    favoriteCollection(
        collection_id: ID!
    ): User! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\FavoriteMutations@favoriteCollection")

    # Unfavorite a collection
    unfavoriteCollection(
        collection_id: ID!
    ): User! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\FavoriteMutations@unfavoriteCollection")

    # ===== WISHLIST MANAGEMENT (Auth required) =====

    # Add item to wishlist (entity_id references Database of Things entity)
    addItemToWishlist(
        entity_id: ID!
    ): Wishlist! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\WishlistMutations@addItemToWishlist")

    # Remove item from wishlist (entity_id references Database of Things entity)
    removeItemFromWishlist(
        entity_id: ID!
    ): String! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\WishlistMutations@removeItemFromWishlist")

    # ===== API TOKEN MANAGEMENT (Auth required) =====

    # Create a new API token
    createApiToken(
        name: String! @rules(apply: ["required", "string", "max:255"])
        abilities: [String!]
        expires_at: DateTime
    ): ApiTokenPayload! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\ApiTokenMutations@createToken")

    # Revoke an API token
    revokeApiToken(
        id: ID! @rules(apply: ["required", "exists:api_tokens,id"])
    ): String! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\ApiTokenMutations@revokeToken")
}
