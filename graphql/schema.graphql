"A date string with format `Y-m-d`, e.g. `2011-05-23`."
scalar Date @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Date")

"A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`."
scalar DateTime @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\DateTime")

scalar JSON

"Can be used as an argument to upload files using https://github.com/jaydenseric/graphql-multipart-request-spec"
scalar Upload @scalar(class: "Nuwave\\Lighthouse\\Schema\\Types\\Scalars\\Upload")

# ===== ENUMS =====

enum EntityType {
    item
    collection
}

enum CategoryType {
    trading_card_games
    figures
    comics
    video_games
    buildables
}

# ===== END ENUMS =====

# ===== DATABASE OF THINGS TYPES =====

# Image stored in the application (user-uploaded or collection images)
type Image {
    id: ID!
    original: String!
    thumbnail: String!
}

# Image from Database of Things (entity/variant/component images)
type EntityImage {
    id: ID!
    image_url: String!
    thumbnail_url: String
}

# Variant from Database of Things (variant of a base entity)
type Variant {
    id: ID!
    name: String!
    attributes: JSON
    image_url: String
    thumbnail_url: String
}

# Component from Database of Things (part of an entity)
type Component {
    id: ID!
    name: String!
    quantity: Int
    order: Int
    attributes: JSON
    image_url: String
    thumbnail_url: String
    additional_images: [EntityImage!]
}

# Entity from Database of Things (canonical collectibles data)
type Entity {
    id: ID!
    type: EntityType!
    name: String!
    category: CategoryType
    year: Int
    country: String
    language: String
    attributes: JSON
    image_url: String
    thumbnail_url: String
    additional_images: [EntityImage!]
    representative_image_urls: [String!] @field(resolver: "App\\GraphQL\\Types\\Entity@representativeImageUrls")
    external_ids: JSON
    source_url: String
    entity_variants: [Variant!]
    entity_components: [Component!]
    created_at: DateTime
    updated_at: DateTime
    similarity: Float
    parents: [Entity!]
}

# Image search result with parent entity information
type ImageSearchResult {
    image_id: ID!
    image_url: String!
    thumbnail_url: String!
    similarity: Float!  # 0.0 to 1.0 (higher = more similar)
    parent_type: String!  # 'entity', 'variant', or 'component'
    parent_id: ID!
    parent_name: String!
}

# Database of Things PageInfo for cursor-based pagination
type DatabaseOfThingsPageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}

# Entity connection for paginated results
type EntityConnection {
    edges: [EntityEdge!]!
    pageInfo: DatabaseOfThingsPageInfo!
}

type EntityEdge {
    node: Entity!
    cursor: String!
}

# Filterable field discovered from collection descendants
type FilterField {
    field: String!
    label: String!
    type: String!
    values: [String!]!
    count: Int!
    priority: Int!
}

# ===== END DATABASE OF THINGS TYPES =====

# ===== USER & AUTH TYPES =====

# User type
type User {
    id: ID!
    name: String!
    email: String!
    email_verified_at: DateTime
    created_at: DateTime!
    updated_at: DateTime!

    "User's custom collections"
    userCollections: [UserCollection!]! @hasMany
}

# User item ownership (pivot with metadata)
# entity_id references Database of Things entity UUID (canonical collectibles data, nullable for custom items)
# variant_id references a specific variant from entity_variants (null = base item)
# name is used for custom items (null for DBoT items)
type UserItem {
    id: ID!
    user_id: ID!
    entity_id: ID
    name: String
    variant_id: ID
    parent_collection_id: ID
    metadata: JSON
    notes: String
    images: [Image!]
    created_at: DateTime!
    updated_at: DateTime!

    user: User! @belongsTo
}

# User item with full entity data (for My Collection view)
# Combines UserItem fields with Entity data from Database of Things
# For custom items, entity fields are null except name (from user_items.name)
type UserItemWithEntity {
    # UserItem fields
    user_item_id: ID!
    user_id: ID!
    parent_collection_id: ID
    variant_id: ID
    user_metadata: JSON
    user_notes: String
    user_images: [Image!]
    user_created_at: DateTime!
    user_updated_at: DateTime!

    # Entity fields (from Database of Things, nullable for custom items)
    id: ID
    "Type of entity: 'item' or 'collection' (matches DBoT EntityType)"
    type: String!
    "Category describing what kind of item: 'custom', 'trading_card_games', etc."
    category: String
    name: String!
    year: Int
    country: String
    attributes: JSON
    image_url: String
    thumbnail_url: String
    representative_image_urls: [String!]
    external_ids: JSON
    entity_variants: [Variant!]
    created_at: DateTime
    updated_at: DateTime
}

# Wishlist entry
# entity_id references Database of Things entity UUID (canonical collectibles data)
# variant_id references a specific variant from entity_variants (null = base item)
type Wishlist {
    id: ID!
    user_id: ID!
    entity_id: ID!
    variant_id: ID
    parent_collection_id: ID
    created_at: DateTime!
    updated_at: DateTime!

    user: User! @belongsTo
}

# Collection statistics
type CollectionStats {
    totalItems: Int!
    catalogedItems: Int!
    ownedItems: Int! @guard
    completionPercentage: Float! @guard
}

# Login response
type AuthPayload {
    access_token: String!
    token_type: String!
    user: User!
}

# API Token type
type ApiToken {
    id: ID!
    name: String!
    abilities: [String!]
    last_used_at: DateTime
    expires_at: DateTime
    created_at: DateTime!
    updated_at: DateTime!
}

# API Token creation response
type ApiTokenPayload {
    token: String!
    apiToken: ApiToken!
}

# Wishlist entry with full entity data (for My Wishlist view)
# Combines Wishlist fields with Entity data from Database of Things
type WishlistWithEntity {
    # Wishlist fields (nullable for untracked items in linked collections)
    wishlist_id: ID
    user_id: ID!
    variant_id: ID
    wishlist_created_at: DateTime
    wishlist_updated_at: DateTime

    # Entity fields (from Database of Things)
    id: ID!
    "Type of entity: 'item' or 'collection' (matches DBoT EntityType)"
    type: String!
    "Category describing what kind of item: 'trading_card_games', etc."
    category: String
    name: String!
    year: Int
    country: String
    attributes: JSON
    image_url: String
    thumbnail_url: String
    representative_image_urls: [String!]
    external_ids: JSON
    entity_variants: [Variant!]
    created_at: DateTime
    updated_at: DateTime
}

"""
User's custom collection for organizing owned and wishlisted items
"""
type UserCollection {
    id: ID!
    user_id: ID!
    parent_collection_id: ID
    name: String!
    "Type of entity: always 'collection' for UserCollection (matches DBoT EntityType)"
    type: String!
    "Category describing what kind of collection: 'custom' or 'linked'"
    category: String!
    description: String
    custom_image: String @deprecated(reason: "Use images array instead")
    images: [Image!]
    linked_dbot_collection_id: ID

    "User who owns this collection"
    user: User! @belongsTo

    "Parent collection (null for root-level collections)"
    parent: UserCollection @belongsTo(relation: "parent")

    "Child collections nested within this collection"
    subcollections: [UserCollection!]! @hasMany(relation: "subcollections")

    "Owned items directly in this collection (non-recursive)"
    items: [UserItemWithEntity!]! @hasMany(relation: "items")

    "Wishlisted items directly in this collection (non-recursive)"
    wishlists: [WishlistWithEntity!]! @hasMany(relation: "wishlists")

    "Progress statistics for this collection"
    progress: CollectionProgress! @field(resolver: "App\\GraphQL\\FieldResolvers\\UserCollectionProgressResolver")

    "Representative images for collection thumbnail (up to 4 images)"
    representative_images: [String!]! @field(resolver: "App\\GraphQL\\FieldResolvers\\UserCollectionRepresentativeImagesResolver")

    "Logo image from linked DBoT collection (null if not linked or no logo)"
    image_url: String @field(resolver: "App\\GraphQL\\FieldResolvers\\UserCollectionImageResolver")

    created_at: DateTime!
    updated_at: DateTime!
}

"""
Collection progress statistics
"""
type CollectionProgress {
    "Number of owned items in collection"
    owned_count: Int!

    "Number of wishlisted items in collection"
    wishlist_count: Int!

    "Total items (owned + wishlist)"
    total_count: Int!

    "Completion percentage (owned / total * 100)"
    percentage: Float!

    "Items owned that exist in linked Database of Things collection (null if not linked)"
    official_owned_count: Int

    "Total items in linked Database of Things collection (null if not linked)"
    official_total_count: Int

    "Official set completion percentage (null if not linked)"
    official_percentage: Float
}

"""
View of a user's collection tree at a specific level
"""
type UserCollectionView {
    "Collections at this level"
    collections: [UserCollection!]!

    "Owned items at this level (not in any subcollection)"
    items: [UserItemWithEntity!]!

    "Wishlisted items at this level (not in any subcollection)"
    wishlists: [WishlistWithEntity!]!

    "Current collection (null for root level)"
    current_collection: UserCollection
}

# ===== END USER & AUTH TYPES =====

# ===== ENUMS =====

enum WishlistMode {
    TRACK @enum(value: "track")
    ADD_TO_EXISTING @enum(value: "add_to_existing")
}

# ===== END ENUMS =====

type Query {
    # ===== AUTHENTICATION =====

    # Current authenticated user
    me: User @auth(guard: "sanctum")

    # ===== DATABASE OF THINGS QUERIES =====

    # Browse collections from Database of Things
    databaseOfThingsCollections(
        first: Int = 50
        after: String
        category: CategoryType
    ): EntityConnection! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\CollectionsList") @trace

    # Search entities in Database of Things
    databaseOfThingsSearch(
        query: String!
        type: EntityType
        category: CategoryType
        first: Int = 50
        after: String
    ): EntityConnection! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\SearchEntities") @trace

    # Semantic search using vector embeddings
    databaseOfThingsSemanticSearch(
        query: String!
        type: EntityType
        category: CategoryType
        first: Int = 20
        after: String
    ): EntityConnection! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\SemanticSearch") @trace

    # Get items in a Database of Things collection
    databaseOfThingsCollectionItems(
        collection_id: ID!
        first: Int = 100
        after: String
    ): EntityConnection! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\CollectionItems") @trace

    # Get a single entity from Database of Things
    databaseOfThingsEntity(
        id: ID!
    ): Entity @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetEntity")

    # Get parent collections for an item from Database of Things
    databaseOfThingsItemParents(
        item_id: ID!
    ): [Entity!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetItemParents")

    # Get filterable fields for a collection (recursively discovers from all descendants)
    databaseOfThingsCollectionFilterFields(
        collection_id: ID!
    ): [FilterField!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetCollectionFilterFields")

    # Get parent collections for items in a collection (excludes the current collection)
    databaseOfThingsCollectionParentCollections(
        collection_id: ID!
    ): [Entity!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetCollectionParentCollections")

    # Get components for an entity from Database of Things
    databaseOfThingsEntityComponents(
        entity_id: ID!
    ): [Component!]! @field(resolver: "App\\GraphQL\\Queries\\DatabaseOfThings\\GetEntityComponents")

    # ===== USER-SPECIFIC QUERIES (Auth required) =====

    # User's owned items (returns UserItem records with entity_id references)
    # Optional entity_id filter for duplicate detection
    myItems(entity_id: ID): [UserItem!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyItems") @trace

    # Single user item with entity data (for item detail view)
    myItem(user_item_id: ID!): UserItemWithEntity @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyItem") @trace

    # User's collection as entities (fetches entity data for owned items with user metadata)
    myCollection: [UserItemWithEntity!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyCollection") @trace

    # User's API tokens
    myApiTokens: [ApiToken!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyApiTokens")

    # User's wishlist items
    myWishlist: [Wishlist!]! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Queries\\MyWishlist")

    """
    Get user's collection tree at a specific level
    Returns collections, items, and wishlists at the specified parent level
    """
    myCollectionTree(parent_id: ID): UserCollectionView!
        @guard
        @field(resolver: "App\\GraphQL\\Queries\\MyCollectionTree")
}

type Mutation {
    # ===== AUTHENTICATION =====

    # Login
    login(
        email: String! @rules(apply: ["required", "email"])
        password: String! @rules(apply: ["required"])
    ): AuthPayload! @field(resolver: "App\\GraphQL\\Mutations\\AuthMutations@login")

    # Logout
    logout: String @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\AuthMutations@logout")

    # Register
    register(
        name: String! @rules(apply: ["required", "string", "max:255"])
        email: String! @rules(apply: ["required", "email", "unique:users,email"])
        password: String! @rules(apply: ["required", "min:8"])
    ): AuthPayload! @field(resolver: "App\\GraphQL\\Mutations\\AuthMutations@register")

    # Google OAuth login
    googleLogin(
        google_token: String! @rules(apply: ["required"])
    ): AuthPayload! @field(resolver: "App\\GraphQL\\Mutations\\AuthMutations@googleLogin")

    # ===== USER ITEM MANAGEMENT (Auth required) =====

    # Add item to user's collection (entity_id references Database of Things entity)
    addItemToMyCollection(
        entity_id: ID!
        variant_id: ID
        metadata: JSON
        notes: String
        images: [Upload!]  # GraphQL multipart upload
    ): UserItem! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserItemMutations@addItemToMyCollection")

    # Add custom item directly to user's collection (no entity_id)
    addCustomItemToMyCollection(
        name: String! @rules(apply: ["required", "min:1", "max:255"])
        parent_collection_id: ID
        notes: String
        images: [Upload!]  # GraphQL multipart upload
    ): UserItem! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserItemMutations@addCustomItemToMyCollection")

    # Update user's item (user_item_id targets specific copy)
    updateMyItem(
        user_item_id: ID!  # Changed from entity_id to target specific copy
        variant_id: ID
        metadata: JSON
        notes: String
        images: [Upload!]  # Add new images
        remove_image_indices: [Int!]  # Remove specific images by index
    ): UserItem! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserItemMutations@updateMyItem")

    # Remove item from user's collection (user_item_id targets specific copy)
    removeItemFromMyCollection(
        user_item_id: ID!  # Changed from entity_id to target specific copy
    ): String! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserItemMutations@removeItemFromMyCollection")

    # Reorder images for a user item (drag-and-drop support)
    reorderItemImages(
        user_item_id: ID!
        image_ids: [ID!]!  # Array of image IDs in desired order
    ): UserItem! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserItemMutations@reorderItemImages")

    # ===== WISHLIST MANAGEMENT (Auth required) =====

    # Add item to wishlist (entity_id references Database of Things entity)
    addItemToWishlist(
        entity_id: ID!
        variant_id: ID
        parent_collection_id: ID
    ): Wishlist! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\WishlistMutations@addItemToWishlist")

    # Remove item from wishlist (entity_id references Database of Things entity)
    removeItemFromWishlist(
        entity_id: ID!
    ): String! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\WishlistMutations@removeItemFromWishlist")

    # ===== USER COLLECTION IMAGE MANAGEMENT (Auth required) =====

    # Upload images to user collection
    uploadCollectionImages(
        collection_id: ID!
        images: [Upload!]!
    ): UserCollection! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserCollectionMutations@uploadCollectionImages")

    # Remove images from user collection
    removeCollectionImages(
        collection_id: ID!
        image_indices: [Int!]!
    ): UserCollection! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserCollectionMutations@removeCollectionImages")

    # Reorder collection images
    reorderCollectionImages(
        collection_id: ID!
        image_ids: [ID!]!
    ): UserCollection! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\UserCollectionMutations@reorderCollectionImages")

    # ===== BATCH OPERATIONS (Auth required) =====

    # Batch add items to collection
    batchAddItemsToMyCollection(
        entity_ids: [ID!]!
        parent_collection_id: ID
    ): BatchItemResult! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\BatchUserItemMutations@batchAddItemsToMyCollection")

    # Batch delete items from collection
    batchRemoveItemsFromMyCollection(
        entity_ids: [ID!]!
    ): BatchItemResult! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\BatchUserItemMutations@batchRemoveItemsFromMyCollection")

    # Batch add items to wishlist
    batchAddItemsToWishlist(
        entity_ids: [ID!]!
        parent_collection_id: ID
    ): BatchItemResult! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\BatchUserItemMutations@batchAddItemsToWishlist")

    # ===== API TOKEN MANAGEMENT (Auth required) =====

    # Create a new API token
    createApiToken(
        name: String! @rules(apply: ["required", "string", "max:255"])
        abilities: [String!]
        expires_at: DateTime
    ): ApiTokenPayload! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\ApiTokenMutations@createToken")

    # Revoke an API token
    revokeApiToken(
        id: ID! @rules(apply: ["required", "exists:api_tokens,id"])
    ): String! @guard(with: ["sanctum"]) @field(resolver: "App\\GraphQL\\Mutations\\ApiTokenMutations@revokeToken")

    # ===== USER COLLECTION MANAGEMENT (Auth required) =====

    """
    Create a new user collection
    """
    createUserCollection(
        name: String! @rules(apply: ["required", "min:1", "max:255"])
        description: String @rules(apply: ["max:1000"])
        parent_id: ID @rules(apply: ["uuid"])
        linked_dbot_collection_id: ID @rules(apply: ["uuid"])
        custom_image: Upload @rules(apply: ["image", "max:2048"])
    ): UserCollection!
        @guard
        @field(resolver: "App\\GraphQL\\Mutations\\CreateUserCollection")

    """
    Move a collection to a different parent (or root level)
    """
    moveUserCollection(
        id: ID! @rules(apply: ["required", "uuid"])
        new_parent_id: ID @rules(apply: ["uuid"])
    ): UserCollection!
        @guard
        @field(resolver: "App\\GraphQL\\Mutations\\MoveUserCollection")

    """
    Soft delete a collection and all its nested contents
    """
    deleteUserCollection(
        id: ID! @rules(apply: ["required", "uuid"])
    ): DeleteCollectionResult!
        @guard
        @field(resolver: "App\\GraphQL\\Mutations\\DeleteUserCollection")

    """
    Preview deletion to show counts of affected items and subcollections
    """
    userCollectionDeletionPreview(
        id: ID! @rules(apply: ["required", "uuid"])
    ): DeletionPreview!
        @guard
        @field(resolver: "App\\GraphQL\\Queries\\UserCollectionDeletionPreview")

    """
    Move a user item to a different collection (or root level)
    """
    moveUserItem(
        item_id: ID! @rules(apply: ["required", "uuid"])
        new_parent_collection_id: ID @rules(apply: ["uuid"])
    ): UserItem!
        @guard
        @field(resolver: "App\\GraphQL\\Mutations\\MoveUserItem")

    """
    Move a wishlist item to a different collection (or root level)
    """
    moveWishlistItem(
        wishlist_id: ID! @rules(apply: ["required", "uuid"])
        new_parent_collection_id: ID @rules(apply: ["uuid"])
    ): Wishlist!
        @guard
        @field(resolver: "App\\GraphQL\\Mutations\\MoveWishlistItem")

    """
    Add entire DBoT collection to wishlist
    Can either track collection (create linked custom collection) or add items to existing collection
    """
    addCollectionToWishlist(
        dbot_collection_id: ID!
        mode: WishlistMode!
        target_collection_id: ID
        new_collection_name: String
    ): AddCollectionResult!
        @guard
        @field(resolver: "App\\GraphQL\\Mutations\\AddCollectionToWishlist")

    # ===== IMAGE SEARCH =====

    """
    Search for items by uploading an image.
    Uses CLIP embeddings to find visually similar items in the Database of Things.
    """
    searchByImage(
        image: Upload! @rules(apply: ["required", "image", "max:10240"])  # Max 10MB
        limit: Int @rules(apply: ["integer", "min:1", "max:50"])
        min_similarity: Float @rules(apply: ["numeric", "min:0", "max:1"])
    ): [ImageSearchResult!]!
        @field(resolver: "App\\GraphQL\\Mutations\\SearchByImage")
}

"""
Result of a delete operation
"""
type DeleteResult {
    success: Boolean!
    message: String
}

"""
Result of batch item operations
"""
type BatchItemResult {
    success: Boolean!
    items_processed: Int!
    items_skipped: Int!
    message: String
}

"""
Result of deleting a user collection
"""
type DeleteCollectionResult {
    success: Boolean!
    deleted_collection_id: ID!
    items_deleted: Int!
    subcollections_deleted: Int!
}

"""
Preview of deletion impact
"""
type DeletionPreview {
    collection_id: ID!
    collection_name: String!
    total_items: Int!
    total_subcollections: Int!
}

"""
Result of adding a collection to wishlist
"""
type AddCollectionResult {
    created_collection: UserCollection
    items_added: Int!
    items_already_owned: Int!
    items_skipped: Int!
}
